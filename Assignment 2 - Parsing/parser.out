Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    UMINUS

Grammar

Rule 0     S' -> global_facts
Rule 1     global_facts -> facts exec_line
Rule 2     facts -> func_def
Rule 3     facts -> assign facts
Rule 4     facts -> empty
Rule 5     func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END
Rule 6     params -> ID_FUNC COMMA params
Rule 7     params -> ID COMMA params
Rule 8     params -> ID_FUNC
Rule 9     params -> ID
Rule 10    assign -> VAL ID ASSIGN stm END
Rule 11    stm -> ID_FUNC LBRACE args RBRACE
Rule 12    args -> ID_FUNC COMMA args
Rule 13    args -> stm COMMA args
Rule 14    args -> ID_FUNC
Rule 15    args -> stm
Rule 16    stm -> stm PLUS stm
Rule 17    stm -> stm MINUS stm
Rule 18    stm -> stm TIMES stm
Rule 19    stm -> stm DIVIDE stm
Rule 20    stm -> stm DOT stm
Rule 21    stm -> stm LESSTHAN stm
Rule 22    stm -> stm GREATERTHAN stm
Rule 23    stm -> stm EQUAL stm
Rule 24    stm -> stm AND stm
Rule 25    stm -> stm OR stm
Rule 26    stm -> STRING
Rule 27    stm -> NUMBER
Rule 28    stm -> TRUE
Rule 29    stm -> FALSE
Rule 30    stm -> NIL
Rule 31    stm -> ID
Rule 32    stm -> LPAREN stm RPAREN
Rule 33    stm -> IF stm THEN stm ELSE stm END
Rule 34    stm -> LET facts IN stm END
Rule 35    stm -> MINUS stm
Rule 36    exec_line -> EXEC stm
Rule 37    empty -> <empty>

Terminals, with rules where they appear

AND                  : 24
ASSIGN               : 5 10
COMMA                : 6 7 12 13
DIVIDE               : 19
DOT                  : 20
ELSE                 : 33
END                  : 5 10 33 34
EQUAL                : 23
EXEC                 : 36
FALSE                : 29
FUNC                 : 5
GREATERTHAN          : 22
ID                   : 7 9 10 31
ID_FUNC              : 5 6 8 11 12 14
IF                   : 33
IN                   : 34
LBRACE               : 5 11
LESSTHAN             : 21
LET                  : 34
LPAREN               : 32
MINUS                : 17 35
NIL                  : 30
NUMBER               : 27
OR                   : 25
PLUS                 : 16
RBRACE               : 5 11
RPAREN               : 32
STRING               : 26
THEN                 : 33
TIMES                : 18
TRUE                 : 28
UMINUS               : 
VAL                  : 10
error                : 

Nonterminals, with rules where they appear

args                 : 11 12 13
assign               : 3
empty                : 4
exec_line            : 1
facts                : 1 3 34
func_def             : 2
global_facts         : 0
params               : 5 6 7
stm                  : 5 10 13 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 32 33 33 33 34 35 36

Parsing method: LALR

state 0

    (0) S' -> . global_facts
    (1) global_facts -> . facts exec_line
    (2) facts -> . func_def
    (3) facts -> . assign facts
    (4) facts -> . empty
    (5) func_def -> . FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END
    (10) assign -> . VAL ID ASSIGN stm END
    (37) empty -> .

    FUNC            shift and go to state 6
    VAL             shift and go to state 7
    EXEC            reduce using rule 37 (empty -> .)

    global_facts                   shift and go to state 1
    facts                          shift and go to state 2
    func_def                       shift and go to state 3
    assign                         shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> global_facts .



state 2

    (1) global_facts -> facts . exec_line
    (36) exec_line -> . EXEC stm

    EXEC            shift and go to state 9

    exec_line                      shift and go to state 8

state 3

    (2) facts -> func_def .

    EXEC            reduce using rule 2 (facts -> func_def .)
    IN              reduce using rule 2 (facts -> func_def .)


state 4

    (3) facts -> assign . facts
    (2) facts -> . func_def
    (3) facts -> . assign facts
    (4) facts -> . empty
    (5) func_def -> . FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END
    (10) assign -> . VAL ID ASSIGN stm END
    (37) empty -> .

    FUNC            shift and go to state 6
    VAL             shift and go to state 7
    EXEC            reduce using rule 37 (empty -> .)
    IN              reduce using rule 37 (empty -> .)

    assign                         shift and go to state 4
    facts                          shift and go to state 10
    func_def                       shift and go to state 3
    empty                          shift and go to state 5

state 5

    (4) facts -> empty .

    EXEC            reduce using rule 4 (facts -> empty .)
    IN              reduce using rule 4 (facts -> empty .)


state 6

    (5) func_def -> FUNC . ID_FUNC LBRACE params RBRACE ASSIGN stm END

    ID_FUNC         shift and go to state 11


state 7

    (10) assign -> VAL . ID ASSIGN stm END

    ID              shift and go to state 12


state 8

    (1) global_facts -> facts exec_line .

    $end            reduce using rule 1 (global_facts -> facts exec_line .)


state 9

    (36) exec_line -> EXEC . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 13

state 10

    (3) facts -> assign facts .

    EXEC            reduce using rule 3 (facts -> assign facts .)
    IN              reduce using rule 3 (facts -> assign facts .)


state 11

    (5) func_def -> FUNC ID_FUNC . LBRACE params RBRACE ASSIGN stm END

    LBRACE          shift and go to state 25


state 12

    (10) assign -> VAL ID . ASSIGN stm END

    ASSIGN          shift and go to state 26


state 13

    (36) exec_line -> EXEC stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    $end            reduce using rule 36 (exec_line -> EXEC stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 14

    (11) stm -> ID_FUNC . LBRACE args RBRACE

    LBRACE          shift and go to state 37


state 15

    (35) stm -> MINUS . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 38

state 16

    (26) stm -> STRING .

    PLUS            reduce using rule 26 (stm -> STRING .)
    MINUS           reduce using rule 26 (stm -> STRING .)
    TIMES           reduce using rule 26 (stm -> STRING .)
    DIVIDE          reduce using rule 26 (stm -> STRING .)
    DOT             reduce using rule 26 (stm -> STRING .)
    LESSTHAN        reduce using rule 26 (stm -> STRING .)
    GREATERTHAN     reduce using rule 26 (stm -> STRING .)
    EQUAL           reduce using rule 26 (stm -> STRING .)
    AND             reduce using rule 26 (stm -> STRING .)
    OR              reduce using rule 26 (stm -> STRING .)
    $end            reduce using rule 26 (stm -> STRING .)
    RPAREN          reduce using rule 26 (stm -> STRING .)
    THEN            reduce using rule 26 (stm -> STRING .)
    END             reduce using rule 26 (stm -> STRING .)
    COMMA           reduce using rule 26 (stm -> STRING .)
    RBRACE          reduce using rule 26 (stm -> STRING .)
    ELSE            reduce using rule 26 (stm -> STRING .)


state 17

    (27) stm -> NUMBER .

    PLUS            reduce using rule 27 (stm -> NUMBER .)
    MINUS           reduce using rule 27 (stm -> NUMBER .)
    TIMES           reduce using rule 27 (stm -> NUMBER .)
    DIVIDE          reduce using rule 27 (stm -> NUMBER .)
    DOT             reduce using rule 27 (stm -> NUMBER .)
    LESSTHAN        reduce using rule 27 (stm -> NUMBER .)
    GREATERTHAN     reduce using rule 27 (stm -> NUMBER .)
    EQUAL           reduce using rule 27 (stm -> NUMBER .)
    AND             reduce using rule 27 (stm -> NUMBER .)
    OR              reduce using rule 27 (stm -> NUMBER .)
    $end            reduce using rule 27 (stm -> NUMBER .)
    RPAREN          reduce using rule 27 (stm -> NUMBER .)
    THEN            reduce using rule 27 (stm -> NUMBER .)
    END             reduce using rule 27 (stm -> NUMBER .)
    COMMA           reduce using rule 27 (stm -> NUMBER .)
    RBRACE          reduce using rule 27 (stm -> NUMBER .)
    ELSE            reduce using rule 27 (stm -> NUMBER .)


state 18

    (28) stm -> TRUE .

    PLUS            reduce using rule 28 (stm -> TRUE .)
    MINUS           reduce using rule 28 (stm -> TRUE .)
    TIMES           reduce using rule 28 (stm -> TRUE .)
    DIVIDE          reduce using rule 28 (stm -> TRUE .)
    DOT             reduce using rule 28 (stm -> TRUE .)
    LESSTHAN        reduce using rule 28 (stm -> TRUE .)
    GREATERTHAN     reduce using rule 28 (stm -> TRUE .)
    EQUAL           reduce using rule 28 (stm -> TRUE .)
    AND             reduce using rule 28 (stm -> TRUE .)
    OR              reduce using rule 28 (stm -> TRUE .)
    $end            reduce using rule 28 (stm -> TRUE .)
    RPAREN          reduce using rule 28 (stm -> TRUE .)
    THEN            reduce using rule 28 (stm -> TRUE .)
    END             reduce using rule 28 (stm -> TRUE .)
    COMMA           reduce using rule 28 (stm -> TRUE .)
    RBRACE          reduce using rule 28 (stm -> TRUE .)
    ELSE            reduce using rule 28 (stm -> TRUE .)


state 19

    (29) stm -> FALSE .

    PLUS            reduce using rule 29 (stm -> FALSE .)
    MINUS           reduce using rule 29 (stm -> FALSE .)
    TIMES           reduce using rule 29 (stm -> FALSE .)
    DIVIDE          reduce using rule 29 (stm -> FALSE .)
    DOT             reduce using rule 29 (stm -> FALSE .)
    LESSTHAN        reduce using rule 29 (stm -> FALSE .)
    GREATERTHAN     reduce using rule 29 (stm -> FALSE .)
    EQUAL           reduce using rule 29 (stm -> FALSE .)
    AND             reduce using rule 29 (stm -> FALSE .)
    OR              reduce using rule 29 (stm -> FALSE .)
    $end            reduce using rule 29 (stm -> FALSE .)
    RPAREN          reduce using rule 29 (stm -> FALSE .)
    THEN            reduce using rule 29 (stm -> FALSE .)
    END             reduce using rule 29 (stm -> FALSE .)
    COMMA           reduce using rule 29 (stm -> FALSE .)
    RBRACE          reduce using rule 29 (stm -> FALSE .)
    ELSE            reduce using rule 29 (stm -> FALSE .)


state 20

    (30) stm -> NIL .

    PLUS            reduce using rule 30 (stm -> NIL .)
    MINUS           reduce using rule 30 (stm -> NIL .)
    TIMES           reduce using rule 30 (stm -> NIL .)
    DIVIDE          reduce using rule 30 (stm -> NIL .)
    DOT             reduce using rule 30 (stm -> NIL .)
    LESSTHAN        reduce using rule 30 (stm -> NIL .)
    GREATERTHAN     reduce using rule 30 (stm -> NIL .)
    EQUAL           reduce using rule 30 (stm -> NIL .)
    AND             reduce using rule 30 (stm -> NIL .)
    OR              reduce using rule 30 (stm -> NIL .)
    $end            reduce using rule 30 (stm -> NIL .)
    RPAREN          reduce using rule 30 (stm -> NIL .)
    THEN            reduce using rule 30 (stm -> NIL .)
    END             reduce using rule 30 (stm -> NIL .)
    COMMA           reduce using rule 30 (stm -> NIL .)
    RBRACE          reduce using rule 30 (stm -> NIL .)
    ELSE            reduce using rule 30 (stm -> NIL .)


state 21

    (31) stm -> ID .

    PLUS            reduce using rule 31 (stm -> ID .)
    MINUS           reduce using rule 31 (stm -> ID .)
    TIMES           reduce using rule 31 (stm -> ID .)
    DIVIDE          reduce using rule 31 (stm -> ID .)
    DOT             reduce using rule 31 (stm -> ID .)
    LESSTHAN        reduce using rule 31 (stm -> ID .)
    GREATERTHAN     reduce using rule 31 (stm -> ID .)
    EQUAL           reduce using rule 31 (stm -> ID .)
    AND             reduce using rule 31 (stm -> ID .)
    OR              reduce using rule 31 (stm -> ID .)
    $end            reduce using rule 31 (stm -> ID .)
    RPAREN          reduce using rule 31 (stm -> ID .)
    THEN            reduce using rule 31 (stm -> ID .)
    END             reduce using rule 31 (stm -> ID .)
    COMMA           reduce using rule 31 (stm -> ID .)
    RBRACE          reduce using rule 31 (stm -> ID .)
    ELSE            reduce using rule 31 (stm -> ID .)


state 22

    (32) stm -> LPAREN . stm RPAREN
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 39

state 23

    (33) stm -> IF . stm THEN stm ELSE stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 40

state 24

    (34) stm -> LET . facts IN stm END
    (2) facts -> . func_def
    (3) facts -> . assign facts
    (4) facts -> . empty
    (5) func_def -> . FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END
    (10) assign -> . VAL ID ASSIGN stm END
    (37) empty -> .

    FUNC            shift and go to state 6
    VAL             shift and go to state 7
    IN              reduce using rule 37 (empty -> .)

    facts                          shift and go to state 41
    func_def                       shift and go to state 3
    assign                         shift and go to state 4
    empty                          shift and go to state 5

state 25

    (5) func_def -> FUNC ID_FUNC LBRACE . params RBRACE ASSIGN stm END
    (6) params -> . ID_FUNC COMMA params
    (7) params -> . ID COMMA params
    (8) params -> . ID_FUNC
    (9) params -> . ID

    ID_FUNC         shift and go to state 42
    ID              shift and go to state 44

    params                         shift and go to state 43

state 26

    (10) assign -> VAL ID ASSIGN . stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 45

state 27

    (16) stm -> stm PLUS . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 46

state 28

    (17) stm -> stm MINUS . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 47

state 29

    (18) stm -> stm TIMES . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 48

state 30

    (19) stm -> stm DIVIDE . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 49

state 31

    (20) stm -> stm DOT . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 50

state 32

    (21) stm -> stm LESSTHAN . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 51

state 33

    (22) stm -> stm GREATERTHAN . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 52

state 34

    (23) stm -> stm EQUAL . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 53

state 35

    (24) stm -> stm AND . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 54

state 36

    (25) stm -> stm OR . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 55

state 37

    (11) stm -> ID_FUNC LBRACE . args RBRACE
    (12) args -> . ID_FUNC COMMA args
    (13) args -> . stm COMMA args
    (14) args -> . ID_FUNC
    (15) args -> . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 56
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    args                           shift and go to state 57
    stm                            shift and go to state 58

state 38

    (35) stm -> MINUS stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    PLUS            reduce using rule 35 (stm -> MINUS stm .)
    MINUS           reduce using rule 35 (stm -> MINUS stm .)
    TIMES           reduce using rule 35 (stm -> MINUS stm .)
    DIVIDE          reduce using rule 35 (stm -> MINUS stm .)
    DOT             reduce using rule 35 (stm -> MINUS stm .)
    LESSTHAN        reduce using rule 35 (stm -> MINUS stm .)
    GREATERTHAN     reduce using rule 35 (stm -> MINUS stm .)
    EQUAL           reduce using rule 35 (stm -> MINUS stm .)
    AND             reduce using rule 35 (stm -> MINUS stm .)
    OR              reduce using rule 35 (stm -> MINUS stm .)
    $end            reduce using rule 35 (stm -> MINUS stm .)
    RPAREN          reduce using rule 35 (stm -> MINUS stm .)
    THEN            reduce using rule 35 (stm -> MINUS stm .)
    END             reduce using rule 35 (stm -> MINUS stm .)
    COMMA           reduce using rule 35 (stm -> MINUS stm .)
    RBRACE          reduce using rule 35 (stm -> MINUS stm .)
    ELSE            reduce using rule 35 (stm -> MINUS stm .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 39

    (32) stm -> LPAREN stm . RPAREN
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    RPAREN          shift and go to state 59
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 40

    (33) stm -> IF stm . THEN stm ELSE stm END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    THEN            shift and go to state 60
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 41

    (34) stm -> LET facts . IN stm END

    IN              shift and go to state 61


state 42

    (6) params -> ID_FUNC . COMMA params
    (8) params -> ID_FUNC .

    COMMA           shift and go to state 62
    RBRACE          reduce using rule 8 (params -> ID_FUNC .)


state 43

    (5) func_def -> FUNC ID_FUNC LBRACE params . RBRACE ASSIGN stm END

    RBRACE          shift and go to state 63


state 44

    (7) params -> ID . COMMA params
    (9) params -> ID .

    COMMA           shift and go to state 64
    RBRACE          reduce using rule 9 (params -> ID .)


state 45

    (10) assign -> VAL ID ASSIGN stm . END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    END             shift and go to state 65
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 46

    (16) stm -> stm PLUS stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    PLUS            reduce using rule 16 (stm -> stm PLUS stm .)
    MINUS           reduce using rule 16 (stm -> stm PLUS stm .)
    DOT             reduce using rule 16 (stm -> stm PLUS stm .)
    LESSTHAN        reduce using rule 16 (stm -> stm PLUS stm .)
    GREATERTHAN     reduce using rule 16 (stm -> stm PLUS stm .)
    EQUAL           reduce using rule 16 (stm -> stm PLUS stm .)
    AND             reduce using rule 16 (stm -> stm PLUS stm .)
    OR              reduce using rule 16 (stm -> stm PLUS stm .)
    $end            reduce using rule 16 (stm -> stm PLUS stm .)
    RPAREN          reduce using rule 16 (stm -> stm PLUS stm .)
    THEN            reduce using rule 16 (stm -> stm PLUS stm .)
    END             reduce using rule 16 (stm -> stm PLUS stm .)
    COMMA           reduce using rule 16 (stm -> stm PLUS stm .)
    RBRACE          reduce using rule 16 (stm -> stm PLUS stm .)
    ELSE            reduce using rule 16 (stm -> stm PLUS stm .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! TIMES           [ reduce using rule 16 (stm -> stm PLUS stm .) ]
  ! DIVIDE          [ reduce using rule 16 (stm -> stm PLUS stm .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 47

    (17) stm -> stm MINUS stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    PLUS            reduce using rule 17 (stm -> stm MINUS stm .)
    MINUS           reduce using rule 17 (stm -> stm MINUS stm .)
    DOT             reduce using rule 17 (stm -> stm MINUS stm .)
    LESSTHAN        reduce using rule 17 (stm -> stm MINUS stm .)
    GREATERTHAN     reduce using rule 17 (stm -> stm MINUS stm .)
    EQUAL           reduce using rule 17 (stm -> stm MINUS stm .)
    AND             reduce using rule 17 (stm -> stm MINUS stm .)
    OR              reduce using rule 17 (stm -> stm MINUS stm .)
    $end            reduce using rule 17 (stm -> stm MINUS stm .)
    RPAREN          reduce using rule 17 (stm -> stm MINUS stm .)
    THEN            reduce using rule 17 (stm -> stm MINUS stm .)
    END             reduce using rule 17 (stm -> stm MINUS stm .)
    COMMA           reduce using rule 17 (stm -> stm MINUS stm .)
    RBRACE          reduce using rule 17 (stm -> stm MINUS stm .)
    ELSE            reduce using rule 17 (stm -> stm MINUS stm .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! TIMES           [ reduce using rule 17 (stm -> stm MINUS stm .) ]
  ! DIVIDE          [ reduce using rule 17 (stm -> stm MINUS stm .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 48

    (18) stm -> stm TIMES stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    PLUS            reduce using rule 18 (stm -> stm TIMES stm .)
    MINUS           reduce using rule 18 (stm -> stm TIMES stm .)
    TIMES           reduce using rule 18 (stm -> stm TIMES stm .)
    DIVIDE          reduce using rule 18 (stm -> stm TIMES stm .)
    DOT             reduce using rule 18 (stm -> stm TIMES stm .)
    LESSTHAN        reduce using rule 18 (stm -> stm TIMES stm .)
    GREATERTHAN     reduce using rule 18 (stm -> stm TIMES stm .)
    EQUAL           reduce using rule 18 (stm -> stm TIMES stm .)
    AND             reduce using rule 18 (stm -> stm TIMES stm .)
    OR              reduce using rule 18 (stm -> stm TIMES stm .)
    $end            reduce using rule 18 (stm -> stm TIMES stm .)
    RPAREN          reduce using rule 18 (stm -> stm TIMES stm .)
    THEN            reduce using rule 18 (stm -> stm TIMES stm .)
    END             reduce using rule 18 (stm -> stm TIMES stm .)
    COMMA           reduce using rule 18 (stm -> stm TIMES stm .)
    RBRACE          reduce using rule 18 (stm -> stm TIMES stm .)
    ELSE            reduce using rule 18 (stm -> stm TIMES stm .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 49

    (19) stm -> stm DIVIDE stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    PLUS            reduce using rule 19 (stm -> stm DIVIDE stm .)
    MINUS           reduce using rule 19 (stm -> stm DIVIDE stm .)
    TIMES           reduce using rule 19 (stm -> stm DIVIDE stm .)
    DIVIDE          reduce using rule 19 (stm -> stm DIVIDE stm .)
    DOT             reduce using rule 19 (stm -> stm DIVIDE stm .)
    LESSTHAN        reduce using rule 19 (stm -> stm DIVIDE stm .)
    GREATERTHAN     reduce using rule 19 (stm -> stm DIVIDE stm .)
    EQUAL           reduce using rule 19 (stm -> stm DIVIDE stm .)
    AND             reduce using rule 19 (stm -> stm DIVIDE stm .)
    OR              reduce using rule 19 (stm -> stm DIVIDE stm .)
    $end            reduce using rule 19 (stm -> stm DIVIDE stm .)
    RPAREN          reduce using rule 19 (stm -> stm DIVIDE stm .)
    THEN            reduce using rule 19 (stm -> stm DIVIDE stm .)
    END             reduce using rule 19 (stm -> stm DIVIDE stm .)
    COMMA           reduce using rule 19 (stm -> stm DIVIDE stm .)
    RBRACE          reduce using rule 19 (stm -> stm DIVIDE stm .)
    ELSE            reduce using rule 19 (stm -> stm DIVIDE stm .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 50

    (20) stm -> stm DOT stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    $end            reduce using rule 20 (stm -> stm DOT stm .)
    RPAREN          reduce using rule 20 (stm -> stm DOT stm .)
    THEN            reduce using rule 20 (stm -> stm DOT stm .)
    END             reduce using rule 20 (stm -> stm DOT stm .)
    COMMA           reduce using rule 20 (stm -> stm DOT stm .)
    RBRACE          reduce using rule 20 (stm -> stm DOT stm .)
    ELSE            reduce using rule 20 (stm -> stm DOT stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36

  ! PLUS            [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! MINUS           [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! TIMES           [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! DIVIDE          [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! DOT             [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! LESSTHAN        [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! GREATERTHAN     [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! EQUAL           [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! AND             [ reduce using rule 20 (stm -> stm DOT stm .) ]
  ! OR              [ reduce using rule 20 (stm -> stm DOT stm .) ]


state 51

    (21) stm -> stm LESSTHAN stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    DOT             reduce using rule 21 (stm -> stm LESSTHAN stm .)
    LESSTHAN        reduce using rule 21 (stm -> stm LESSTHAN stm .)
    GREATERTHAN     reduce using rule 21 (stm -> stm LESSTHAN stm .)
    EQUAL           reduce using rule 21 (stm -> stm LESSTHAN stm .)
    AND             reduce using rule 21 (stm -> stm LESSTHAN stm .)
    OR              reduce using rule 21 (stm -> stm LESSTHAN stm .)
    $end            reduce using rule 21 (stm -> stm LESSTHAN stm .)
    RPAREN          reduce using rule 21 (stm -> stm LESSTHAN stm .)
    THEN            reduce using rule 21 (stm -> stm LESSTHAN stm .)
    END             reduce using rule 21 (stm -> stm LESSTHAN stm .)
    COMMA           reduce using rule 21 (stm -> stm LESSTHAN stm .)
    RBRACE          reduce using rule 21 (stm -> stm LESSTHAN stm .)
    ELSE            reduce using rule 21 (stm -> stm LESSTHAN stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! PLUS            [ reduce using rule 21 (stm -> stm LESSTHAN stm .) ]
  ! MINUS           [ reduce using rule 21 (stm -> stm LESSTHAN stm .) ]
  ! TIMES           [ reduce using rule 21 (stm -> stm LESSTHAN stm .) ]
  ! DIVIDE          [ reduce using rule 21 (stm -> stm LESSTHAN stm .) ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 52

    (22) stm -> stm GREATERTHAN stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    DOT             reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    LESSTHAN        reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    GREATERTHAN     reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    EQUAL           reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    AND             reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    OR              reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    $end            reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    RPAREN          reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    THEN            reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    END             reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    COMMA           reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    RBRACE          reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    ELSE            reduce using rule 22 (stm -> stm GREATERTHAN stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! PLUS            [ reduce using rule 22 (stm -> stm GREATERTHAN stm .) ]
  ! MINUS           [ reduce using rule 22 (stm -> stm GREATERTHAN stm .) ]
  ! TIMES           [ reduce using rule 22 (stm -> stm GREATERTHAN stm .) ]
  ! DIVIDE          [ reduce using rule 22 (stm -> stm GREATERTHAN stm .) ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 53

    (23) stm -> stm EQUAL stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    DOT             reduce using rule 23 (stm -> stm EQUAL stm .)
    LESSTHAN        reduce using rule 23 (stm -> stm EQUAL stm .)
    GREATERTHAN     reduce using rule 23 (stm -> stm EQUAL stm .)
    EQUAL           reduce using rule 23 (stm -> stm EQUAL stm .)
    AND             reduce using rule 23 (stm -> stm EQUAL stm .)
    OR              reduce using rule 23 (stm -> stm EQUAL stm .)
    $end            reduce using rule 23 (stm -> stm EQUAL stm .)
    RPAREN          reduce using rule 23 (stm -> stm EQUAL stm .)
    THEN            reduce using rule 23 (stm -> stm EQUAL stm .)
    END             reduce using rule 23 (stm -> stm EQUAL stm .)
    COMMA           reduce using rule 23 (stm -> stm EQUAL stm .)
    RBRACE          reduce using rule 23 (stm -> stm EQUAL stm .)
    ELSE            reduce using rule 23 (stm -> stm EQUAL stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! PLUS            [ reduce using rule 23 (stm -> stm EQUAL stm .) ]
  ! MINUS           [ reduce using rule 23 (stm -> stm EQUAL stm .) ]
  ! TIMES           [ reduce using rule 23 (stm -> stm EQUAL stm .) ]
  ! DIVIDE          [ reduce using rule 23 (stm -> stm EQUAL stm .) ]
  ! DOT             [ shift and go to state 31 ]
  ! LESSTHAN        [ shift and go to state 32 ]
  ! GREATERTHAN     [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 34 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 54

    (24) stm -> stm AND stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    DOT             reduce using rule 24 (stm -> stm AND stm .)
    AND             reduce using rule 24 (stm -> stm AND stm .)
    OR              reduce using rule 24 (stm -> stm AND stm .)
    $end            reduce using rule 24 (stm -> stm AND stm .)
    RPAREN          reduce using rule 24 (stm -> stm AND stm .)
    THEN            reduce using rule 24 (stm -> stm AND stm .)
    END             reduce using rule 24 (stm -> stm AND stm .)
    COMMA           reduce using rule 24 (stm -> stm AND stm .)
    RBRACE          reduce using rule 24 (stm -> stm AND stm .)
    ELSE            reduce using rule 24 (stm -> stm AND stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34

  ! PLUS            [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! MINUS           [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! TIMES           [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! DIVIDE          [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! LESSTHAN        [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! GREATERTHAN     [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! EQUAL           [ reduce using rule 24 (stm -> stm AND stm .) ]
  ! DOT             [ shift and go to state 31 ]
  ! AND             [ shift and go to state 35 ]
  ! OR              [ shift and go to state 36 ]


state 55

    (25) stm -> stm OR stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    DOT             reduce using rule 25 (stm -> stm OR stm .)
    OR              reduce using rule 25 (stm -> stm OR stm .)
    $end            reduce using rule 25 (stm -> stm OR stm .)
    RPAREN          reduce using rule 25 (stm -> stm OR stm .)
    THEN            reduce using rule 25 (stm -> stm OR stm .)
    END             reduce using rule 25 (stm -> stm OR stm .)
    COMMA           reduce using rule 25 (stm -> stm OR stm .)
    RBRACE          reduce using rule 25 (stm -> stm OR stm .)
    ELSE            reduce using rule 25 (stm -> stm OR stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35

  ! PLUS            [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! MINUS           [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! TIMES           [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! DIVIDE          [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! LESSTHAN        [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! GREATERTHAN     [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! EQUAL           [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! AND             [ reduce using rule 25 (stm -> stm OR stm .) ]
  ! DOT             [ shift and go to state 31 ]
  ! OR              [ shift and go to state 36 ]


state 56

    (12) args -> ID_FUNC . COMMA args
    (14) args -> ID_FUNC .
    (11) stm -> ID_FUNC . LBRACE args RBRACE

    COMMA           shift and go to state 66
    RBRACE          reduce using rule 14 (args -> ID_FUNC .)
    LBRACE          shift and go to state 37


state 57

    (11) stm -> ID_FUNC LBRACE args . RBRACE

    RBRACE          shift and go to state 67


state 58

    (13) args -> stm . COMMA args
    (15) args -> stm .
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    COMMA           shift and go to state 68
    RBRACE          reduce using rule 15 (args -> stm .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 59

    (32) stm -> LPAREN stm RPAREN .

    PLUS            reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    MINUS           reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    TIMES           reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    DIVIDE          reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    DOT             reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    LESSTHAN        reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    GREATERTHAN     reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    EQUAL           reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    AND             reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    OR              reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    $end            reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    RPAREN          reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    THEN            reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    END             reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    COMMA           reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    RBRACE          reduce using rule 32 (stm -> LPAREN stm RPAREN .)
    ELSE            reduce using rule 32 (stm -> LPAREN stm RPAREN .)


state 60

    (33) stm -> IF stm THEN . stm ELSE stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 69

state 61

    (34) stm -> LET facts IN . stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 70

state 62

    (6) params -> ID_FUNC COMMA . params
    (6) params -> . ID_FUNC COMMA params
    (7) params -> . ID COMMA params
    (8) params -> . ID_FUNC
    (9) params -> . ID

    ID_FUNC         shift and go to state 42
    ID              shift and go to state 44

    params                         shift and go to state 71

state 63

    (5) func_def -> FUNC ID_FUNC LBRACE params RBRACE . ASSIGN stm END

    ASSIGN          shift and go to state 72


state 64

    (7) params -> ID COMMA . params
    (6) params -> . ID_FUNC COMMA params
    (7) params -> . ID COMMA params
    (8) params -> . ID_FUNC
    (9) params -> . ID

    ID_FUNC         shift and go to state 42
    ID              shift and go to state 44

    params                         shift and go to state 73

state 65

    (10) assign -> VAL ID ASSIGN stm END .

    FUNC            reduce using rule 10 (assign -> VAL ID ASSIGN stm END .)
    VAL             reduce using rule 10 (assign -> VAL ID ASSIGN stm END .)
    EXEC            reduce using rule 10 (assign -> VAL ID ASSIGN stm END .)
    IN              reduce using rule 10 (assign -> VAL ID ASSIGN stm END .)


state 66

    (12) args -> ID_FUNC COMMA . args
    (12) args -> . ID_FUNC COMMA args
    (13) args -> . stm COMMA args
    (14) args -> . ID_FUNC
    (15) args -> . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 56
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    args                           shift and go to state 74
    stm                            shift and go to state 58

state 67

    (11) stm -> ID_FUNC LBRACE args RBRACE .

    PLUS            reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    MINUS           reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    TIMES           reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    DIVIDE          reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    DOT             reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    LESSTHAN        reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    GREATERTHAN     reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    EQUAL           reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    AND             reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    OR              reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    $end            reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    RPAREN          reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    THEN            reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    END             reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    COMMA           reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    RBRACE          reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)
    ELSE            reduce using rule 11 (stm -> ID_FUNC LBRACE args RBRACE .)


state 68

    (13) args -> stm COMMA . args
    (12) args -> . ID_FUNC COMMA args
    (13) args -> . stm COMMA args
    (14) args -> . ID_FUNC
    (15) args -> . stm
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 56
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 58
    args                           shift and go to state 75

state 69

    (33) stm -> IF stm THEN stm . ELSE stm END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    ELSE            shift and go to state 76
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 70

    (34) stm -> LET facts IN stm . END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    END             shift and go to state 77
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 71

    (6) params -> ID_FUNC COMMA params .

    RBRACE          reduce using rule 6 (params -> ID_FUNC COMMA params .)


state 72

    (5) func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN . stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 78

state 73

    (7) params -> ID COMMA params .

    RBRACE          reduce using rule 7 (params -> ID COMMA params .)


state 74

    (12) args -> ID_FUNC COMMA args .

    RBRACE          reduce using rule 12 (args -> ID_FUNC COMMA args .)


state 75

    (13) args -> stm COMMA args .

    RBRACE          reduce using rule 13 (args -> stm COMMA args .)


state 76

    (33) stm -> IF stm THEN stm ELSE . stm END
    (11) stm -> . ID_FUNC LBRACE args RBRACE
    (16) stm -> . stm PLUS stm
    (17) stm -> . stm MINUS stm
    (18) stm -> . stm TIMES stm
    (19) stm -> . stm DIVIDE stm
    (20) stm -> . stm DOT stm
    (21) stm -> . stm LESSTHAN stm
    (22) stm -> . stm GREATERTHAN stm
    (23) stm -> . stm EQUAL stm
    (24) stm -> . stm AND stm
    (25) stm -> . stm OR stm
    (26) stm -> . STRING
    (27) stm -> . NUMBER
    (28) stm -> . TRUE
    (29) stm -> . FALSE
    (30) stm -> . NIL
    (31) stm -> . ID
    (32) stm -> . LPAREN stm RPAREN
    (33) stm -> . IF stm THEN stm ELSE stm END
    (34) stm -> . LET facts IN stm END
    (35) stm -> . MINUS stm

    ID_FUNC         shift and go to state 14
    STRING          shift and go to state 16
    NUMBER          shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NIL             shift and go to state 20
    ID              shift and go to state 21
    LPAREN          shift and go to state 22
    IF              shift and go to state 23
    LET             shift and go to state 24
    MINUS           shift and go to state 15

    stm                            shift and go to state 79

state 77

    (34) stm -> LET facts IN stm END .

    PLUS            reduce using rule 34 (stm -> LET facts IN stm END .)
    MINUS           reduce using rule 34 (stm -> LET facts IN stm END .)
    TIMES           reduce using rule 34 (stm -> LET facts IN stm END .)
    DIVIDE          reduce using rule 34 (stm -> LET facts IN stm END .)
    DOT             reduce using rule 34 (stm -> LET facts IN stm END .)
    LESSTHAN        reduce using rule 34 (stm -> LET facts IN stm END .)
    GREATERTHAN     reduce using rule 34 (stm -> LET facts IN stm END .)
    EQUAL           reduce using rule 34 (stm -> LET facts IN stm END .)
    AND             reduce using rule 34 (stm -> LET facts IN stm END .)
    OR              reduce using rule 34 (stm -> LET facts IN stm END .)
    $end            reduce using rule 34 (stm -> LET facts IN stm END .)
    RPAREN          reduce using rule 34 (stm -> LET facts IN stm END .)
    THEN            reduce using rule 34 (stm -> LET facts IN stm END .)
    END             reduce using rule 34 (stm -> LET facts IN stm END .)
    COMMA           reduce using rule 34 (stm -> LET facts IN stm END .)
    RBRACE          reduce using rule 34 (stm -> LET facts IN stm END .)
    ELSE            reduce using rule 34 (stm -> LET facts IN stm END .)


state 78

    (5) func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm . END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    END             shift and go to state 80
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 79

    (33) stm -> IF stm THEN stm ELSE stm . END
    (16) stm -> stm . PLUS stm
    (17) stm -> stm . MINUS stm
    (18) stm -> stm . TIMES stm
    (19) stm -> stm . DIVIDE stm
    (20) stm -> stm . DOT stm
    (21) stm -> stm . LESSTHAN stm
    (22) stm -> stm . GREATERTHAN stm
    (23) stm -> stm . EQUAL stm
    (24) stm -> stm . AND stm
    (25) stm -> stm . OR stm

    END             shift and go to state 81
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    DOT             shift and go to state 31
    LESSTHAN        shift and go to state 32
    GREATERTHAN     shift and go to state 33
    EQUAL           shift and go to state 34
    AND             shift and go to state 35
    OR              shift and go to state 36


state 80

    (5) func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END .

    EXEC            reduce using rule 5 (func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END .)
    IN              reduce using rule 5 (func_def -> FUNC ID_FUNC LBRACE params RBRACE ASSIGN stm END .)


state 81

    (33) stm -> IF stm THEN stm ELSE stm END .

    PLUS            reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    MINUS           reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    TIMES           reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    DIVIDE          reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    DOT             reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    LESSTHAN        reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    GREATERTHAN     reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    EQUAL           reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    AND             reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    OR              reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    $end            reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    RPAREN          reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    THEN            reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    END             reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    COMMA           reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    RBRACE          reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)
    ELSE            reduce using rule 33 (stm -> IF stm THEN stm ELSE stm END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 50 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 50 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 50 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 50 resolved as shift
WARNING: shift/reduce conflict for DOT in state 50 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 50 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 50 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 50 resolved as shift
WARNING: shift/reduce conflict for AND in state 50 resolved as shift
WARNING: shift/reduce conflict for OR in state 50 resolved as shift
